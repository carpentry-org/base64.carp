(use-all Array Char Int String)

(defmodule Base64

  (doc mime-charset "The Base64 character set as specified by MIME.")
  (def mime-charset [
    \A \B \C \D \E \F \G \H \I \J \K \L \M \N \O \P \Q
    \R \S \T \U \V \W \X \Y \Z \a \b \c \d \e \f \g \h
    \i \j \k \l \m \n \o \p \q \r \s \t \u \v \w \x \y
    \z \0 \1 \2 \3 \4 \5 \6 \7 \8 \9 \+ \/
  ])

  (doc mime-padding "The Base64 padding as specified by MIME.")
  (def mime-padding \=)

  (doc decode-using "Decodes a base64-encoded datum using a user-supplied character set.")
  (sig decode-using (λ [&(Array Char) &Char &String] (Array Int)))
  (defn decode-using [charset padding str]
      (let-do [bytes (chars str)
            decoded []]
        (while (/= (length &bytes) 0)
          (let-do [b0 (Maybe.from (Array.index-of charset (unsafe-nth &bytes 0)) 0)
                   b1 (Maybe.from (Array.index-of charset (unsafe-nth &bytes 1)) 0)
                   third (unsafe-nth &bytes 2)
                   b2 (Maybe.from (Array.index-of charset third) 0)
                   fourth (unsafe-nth &bytes 3)
                   b3 (Maybe.from (Array.index-of charset fourth) 0)]
            (set! bytes (suffix &bytes 4))
            (set! decoded (Array.push-back decoded (bit-or (bit-shift-left (bit-and b0 63) 2) (bit-shift-right b1 4))))
            (when (/= third padding)
              (set! decoded (Array.push-back decoded (bit-or (bit-shift-left (bit-and b1 15) 4) (bit-shift-right b2 2)))))
            (when (/= fourth padding)
              (set! decoded (Array.push-back decoded (bit-or (bit-shift-left (bit-and b2 3) 6) b3))))))
        decoded))

  (doc decode "Decodes a base64-encoded datum using mime-charset.")
  (defn decode [str]
    (decode-using &mime-charset &mime-padding str))

  (doc decode-str "Decodes a base64-encoded string using mime-charset.")
  (defn decode-str [str]
    (from-chars &(copy-map &(fn [x] (from-int @x))
                           &(decode-using &mime-charset &mime-padding str))))

  (doc encode-using "Encodes a base64-encoded datum using a user-supplied character set.")
  (sig encode-using (λ [&(Array Char) Char &(Array Int)] String))
  (defn encode-using [charset pad s]
    (let-do [l (Array.length s)
             idx 0
             enc @""]
      (while (> l idx)
        (let-do [b0 @(unsafe-nth s idx)]
        (case (- l idx)
          1
            (let-do [c0 (unsafe-nth charset (bit-shift-right b0 2))
                     c1 (unsafe-nth charset (bit-shift-left (bit-and b0 3) 4))]
              (set! enc (str* enc @c0 @c1 pad pad))
              (break))
          2
            (let-do [b1 @(unsafe-nth s (inc idx))
                     c0 (unsafe-nth charset (bit-shift-right b0 2))
                     c1 (unsafe-nth charset (bit-or (bit-shift-left (bit-and b0 3) 4)
                                             (bit-shift-right b1 4)))
                     c2 (unsafe-nth charset (bit-shift-left (bit-and b1 15) 2))
                     ]
              (set! enc (str* enc @c0 @c1 @c2 pad))
              (break))
          (let-do [b1 @(unsafe-nth s (inc idx))
                   b2 @(unsafe-nth s (+ idx 2))
                   c0 (unsafe-nth charset (bit-shift-right b0 2))
                   c1 (unsafe-nth charset (bit-or (bit-shift-left (bit-and b0 3) 4)
                                           (bit-shift-right b1 4)))
                   c2 (unsafe-nth charset (bit-or (bit-shift-left (bit-and b1 15) 2)
                                           (bit-shift-right b2 6)))
                   c3 (unsafe-nth charset (bit-and b2 63))
                   ]
            (set! enc (str* enc @c0 @c1 @c2 @c3))
            (set! idx (+ idx 3))))))
        enc))

  (doc encode "Encodes a datum into base64 using mime-charset.")
  (defn encode [s]
    (encode-using &mime-charset mime-padding s))

  (doc encode-str "Encodes a string into base64 using mime-charset.")
  (defn encode-str [s]
    (encode-using &mime-charset mime-padding &(copy-map &(fn [x] (to-int @x))
                                                        &(chars s))))
)
